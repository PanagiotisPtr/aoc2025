package com.panagiotispetridis.day12;

import java.util.Arrays;

// DLX with column weights for "exactly K" constraints
// !!! GENERATED BY AI - I'M NOT GOOD ENOUGH TO WRITE THIS !!!
public class DLX {

    // Node structure
    static class Node {
        Node L, R, U, D;
        Column C;
        int rowId;
    }

    // Column header with weight and usage
    static class Column extends Node {
        int size = 0;
        int index;

        // For weighted columns (shapes)
        int required = 1;   // default exact-1
        int used = 0;

        boolean isWeighted = false;

        Column(int idx) { this.index = idx; this.C = this; }
    }

    private final Column header;
    private final Column[] columns;

    // For row → shapeId mapping
    private int[] rowShape;

    private boolean solutionFound = false;

    public DLX(int numColumns, int numRows) {
        header = new Column(-1);
        columns = new Column[numColumns];
        rowShape = new int[numRows];
        Arrays.fill(rowShape, -1);

        Column prev = header;
        for (int i = 0; i < numColumns; i++) {
            Column c = new Column(i);
            columns[i] = c;

            prev.R = c;
            c.L = prev;
            prev = c;

            c.U = c.D = c; // vertical loop
        }

        prev.R = header;
        header.L = prev;
    }

    // Mark a column as weighted with requirement K
    public void setWeightedRequirement(int colIdx, int required) {
        Column c = columns[colIdx];
        c.isWeighted = true;
        c.required = required;
    }

    private int nextRowId = 0;

    // Add row for given columns → includes shape column
    public void addRow(int[] colIdxs, int shapeId) {
        Node first = null;
        Node prev = null;

        for (int idx : colIdxs) {
            Column col = columns[idx];
            Node node = new Node();
            node.C = col;
            node.rowId = nextRowId;

            // vertical insert
            node.D = col;
            node.U = col.U;
            col.U.D = node;
            col.U = node;

            col.size++;

            // horizontal insert
            if (first == null) {
                first = node;
                prev = node;
                node.L = node.R = node;
            } else {
                node.R = first;
                node.L = prev;
                prev.R = node;
                first.L = node;
                prev = node;
            }
        }

        rowShape[nextRowId] = shapeId;
        nextRowId++;
    }

    // Cover column
    private void cover(Column c) {
        c.R.L = c.L;
        c.L.R = c.R;

        for (Node row = c.D; row != c; row = row.D)
            for (Node j = row.R; j != row; j = j.R) {
                j.D.U = j.U;
                j.U.D = j.D;
                j.C.size--;
            }
    }

    // Uncover column
    private void uncover(Column c) {
        for (Node row = c.U; row != c; row = row.U)
            for (Node j = row.L; j != row; j = j.L) {
                j.C.size++;
                j.D.U = j;
                j.U.D = j;
            }

        c.R.L = c;
        c.L.R = c;
    }

    // Return the column with smallest size (Algorithm X heuristic)
    private Column chooseColumn() {
        int best = Integer.MAX_VALUE;
        Column bestCol = null;

        for (Column c = (Column) header.R; c != header; c = (Column) c.R) {
            if (!c.isWeighted && c.size < best) {
                best = c.size;
                bestCol = c;
            }
        }
        return bestCol;
    }

    public boolean solveExists() {
        search();
        return solutionFound;
    }

    private void search() {
        if (solutionFound) return;

        if (header.R == header) {
            // Check weighted column requirements
            for (Column c : columns) {
                if (c.isWeighted && c.used != c.required)
                    return;
            }
            solutionFound = true;
            return;
        }

        Column col = chooseColumn();
        if (col == null || col.size == 0)
            return;

        cover(col);

        for (Node r = col.D; r != col; r = r.D) {

            // Update shape usage
            int shapeId = rowShape[r.rowId];
            if (shapeId >= 0) {
                Column shapeCol = columns[shapeId];
                shapeCol.used++;

                if (shapeCol.used > shapeCol.required) {
                    // prune
                    shapeCol.used--;
                    continue;
                }
            }

            for (Node j = r.R; j != r; j = j.R) {
                cover(j.C);
                int sid = rowShape[j.rowId];
                if (sid >= 0) {
                    Column sc = columns[sid];
                    sc.used++;
                    if (sc.used > sc.required) {
                        // rollback covers for this row
                        for (Node k = j.L; k != r; k = k.L) uncover(k.C);
                        if (shapeId >= 0) columns[shapeId].used--;
                        continue;
                    }
                }
            }

            search();
            if (solutionFound) return;

            // rollback
            for (Node j = r.L; j != r; j = j.L)
                uncover(j.C);

            if (shapeId >= 0)
                columns[shapeId].used--;
        }

        uncover(col);
    }
}